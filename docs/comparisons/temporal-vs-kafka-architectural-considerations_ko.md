# Temporal vs Kafka: 문서 처리 파이프라인을 위한 아키텍처 고려사항

## 요약

Kafka는 고처리량, 장애 허용, 확장 가능한 데이터 파이프라인 구축에 매우 강력하지만, *너무 많은* 토픽을 사용하고 과도한 토픽 간 라우팅으로 *지나치게 복잡한 플로우*를 만드는 것은 심각한 아키텍처 단점을 초래할 수 있습니다. 이 문서는 복잡한 문서 처리 워크플로우에서 Temporal이 더 나은 선택일 수 있는 이유와 Kafka의 복잡성이 안티패턴이 되는 시점을 살펴봅니다.

## Kafka 안티패턴: 너무 많은 토픽, 너무 복잡한 플로우

### 과도한 토픽 증가의 단점

#### 1. 운영 복잡성 증가
- **관리 오버헤드**: 각 토픽은 구성(보존 정책, 복제 계수, 파티션), 모니터링, 잠재적으로 ACL이 필요합니다. 수백 또는 수천 개의 토픽을 관리하는 것은 상당한 관리 부담이 됩니다
- **디버깅 악몽**: 수많은 토픽에 걸쳐 메시지를 추적하고 데이터 계보를 이해하는 것이 기하급수적으로 어려워집니다
- **스키마 관리**: 토픽 전반에 걸친 여러 데이터 유형은 각각에 대한 강력한 스키마 관리(Schema Registry)가 필요하여 복잡성을 배가시킵니다

#### 2. 리소스 소비 및 메타데이터 부담
- **브로커 부하**: 과도한 메타데이터는 브로커와 ZooKeeper/KRaft에 부담을 주어 클러스터 안정성과 성능에 영향을 줍니다
- **메모리 및 디스크**: 더 많은 토픽은 토픽 메타데이터와 복제를 관리하기 위한 더 많은 열린 파일 핸들과 메모리 소비를 의미합니다
- **네트워크 오버헤드**: 토픽 간 라우팅은 불필요한 네트워크 트래픽을 생성합니다

#### 3. 컨슈머 관리 과제
- **구독 복잡성**: 많은 토픽을 구독하는 컨슈머는 구성하고 관리하기가 번거로워집니다
- **비효율적인 필터링**: 컨슈머가 메시지의 80% 이상을 버릴 때 주로 필터링을 위해 여러 토픽을 사용합니다
- **리밸런스 폭풍**: 많은 토픽에 걸친 빈번한 컨슈머 그룹 리밸런스는 처리 일시 중지를 야기합니다

#### 4. 잘못된 설계 원칙
- **불명확한 도메인 경계**: 과도한 토픽은 종종 잘못된 도메인 모델링을 나타냅니다
- **과도한 세분화**: 단일 `user-events` 토픽으로 충분할 때 `user-login-events`, `user-logout-events`, `user-profile-update-events`와 같은 토픽을 만드는 것
- **마이크로 이벤트 안티패턴**: 논리적으로 그룹화된 이벤트 스트림이 아닌 이벤트별 토픽

### 스파게티 플로우 문제

과도한 토픽 체이닝(A → B → C → D → E)을 가진 복잡한 Kafka 플로우는 다음을 생성합니다:

#### 1. 누적된 지연 시간
- 각 홉은 네트워크 왕복, 직렬화/역직렬화, 처리 지연을 도입합니다
- 긴 체인은 지연 시간을 기하급수적으로 누적시킵니다

#### 2. 관찰성 악몽
- **분산 추적**: 5-10개의 토픽을 통해 메시지를 추적하려면 정교한 분산 추적이 필요합니다
- **병목 감지**: 복잡한 플로우에서 성능 문제를 정확히 찾아내는 것은 힘든 일입니다
- **오류 귀속**: 다중 홉 플로우에서 실패 원인을 결정하는 것은 거의 불가능합니다

#### 3. 유지보수 지옥
- **인지 부하**: 전체 데이터 플로우를 이해하려면 상당한 정신적 노력이 필요합니다
- **변경 파급 효과**: 한 단계를 수정하면 전체 다운스트림 체인에 영향을 미칩니다
- **스키마 진화**: 변환 단계 전반에 걸쳐 스키마 변경을 조정하는 것

#### 4. 리소스 비효율성
- **중복 처리**: 메시지가 여러 번 필터링/변환됩니다
- **스토리지 오버헤드**: 각 중간 토픽은 디스크 공간과 복제가 필요합니다
- **트랜잭션 복잡성**: 체인된 토픽에서 정확히 한 번 의미론을 달성하는 것은 매우 어렵습니다

## 문서 처리에서 Temporal이 우수한 이유

### 1. 워크플로우 중심 아키텍처
```java
@WorkflowMethod
public PipelineResult runPipeline(PipelineInput input) {
    // 명확하고 선형적인 워크플로우 정의
    var documents = activities.parseCSV(input.getCsvPath());
    var ingested = activities.downloadAndValidate(documents);
    var preprocessed = activities.preprocessBatch(ingested);
    var inferred = activities.runInference(preprocessed);
    var postprocessed = activities.enhanceQuality(inferred);
    var stored = activities.storeResults(postprocessed);
    return buildResult(stored);
}
```

**이점:**
- **단일 진실의 원천**: 전체 파이프라인 로직이 한 곳에
- **명확한 종속성**: 단계 종속성이 명시적
- **내장 오케스트레이션**: 외부 조정이 필요 없음

### 2. 우수한 오류 처리 및 신뢰성
```java
@ActivityMethod
public ProcessingResult processDocument(Document doc) {
    // 지수 백오프를 사용한 자동 재시도
    // 데드 레터 처리 내장
    // 보상 패턴 지원
}
```

**Temporal 장점:**
- **자동 재시도**: 액티비티별 구성 가능한 재시도 정책
- **보상 패턴**: 내장 사가 패턴 지원
- **실패 격리**: 실패한 액티비티가 전체 파이프라인에 영향을 주지 않음
- **상태 복구**: 워크플로우가 정확한 실패 지점에서 재개

### 3. 상태 관리 및 내구성
- **영구 상태**: 워크플로우 상태가 자동으로 유지됨
- **재생 안전성**: 결정론적 실행으로 안전한 재생 가능
- **장기 실행 워크플로우**: 시간/일에 걸친 프로세스 처리
- **이벤트 소싱**: 모든 워크플로우 이벤트의 완전한 감사 추적

### 4. 단순화된 모니터링 및 관찰성
- **내장 추적**: 모든 워크플로우 실행이 처음부터 끝까지 추적됨
- **상태 가시성**: 현재 워크플로우 상태에 항상 접근 가능
- **메트릭 통합**: Prometheus, Grafana 통합 기본 제공
- **타임라인 뷰**: 워크플로우 실행의 시각적 표현

## Kafka 복잡성이 안티패턴이 되는 시점

### 문서 처리 파이프라인 예제

**나쁜 Kafka 아키텍처:**
```
CSV 토픽 → 다운로드 토픽 → 검증 토픽 → 
텍스트 추출 토픽 → 전처리 토픽 → 
임베딩 토픽 → 품질 토픽 → 저장 토픽
```

**문제점:**
- 단일 파이프라인에 8개 토픽
- 유지 관리할 7개 컨슈머 애플리케이션
- 토픽 전반의 복잡한 오류 처리
- 파이프라인을 통한 문서 추적 어려움
- 스키마 조정 악몽
- 높은 운영 오버헤드

**더 나은 Temporal 아키텍처:**
```java
public class DocumentPipelineWorkflow {
    // 단일 워크플로우가 전체 파이프라인 오케스트레이션
    // 액티비티가 개별 단계 처리
    // 내장 오류 처리 및 재시도
    // 완전한 가시성 및 추적
}
```

### 리소스 활용 비교

| 측면 | 복잡한 Kafka 플로우 | Temporal 워크플로우 |
|--------|-------------------|-------------------|
| **토픽/큐** | 8개 이상 토픽 | 1개 작업 큐 |
| **애플리케이션** | 7개 이상 마이크로서비스 | 1개 워커 서비스 |
| **오류 처리** | 서비스별 수동 처리 | 내장 패턴 |
| **모니터링** | 7개 이상 대시보드 | 1개 워크플로우 뷰 |
| **배포** | 7개 이상 배포 | 1개 배포 |
| **상태 관리** | 외부 저장소 | 내장 영속성 |

## 모범 사례: 언제 무엇을 선택할 것인가

### Temporal을 선택해야 할 때:
- **복잡한 오케스트레이션**: 종속성이 있는 다단계 워크플로우
- **장기 실행 프로세스**: 몇 분에서 며칠에 걸친 워크플로우
- **오류 복구**: 정교한 재시도 및 보상 로직 필요
- **상태 관리**: 워크플로우 상태가 중요함
- **인간 작업**: 자동화된 프로세스의 수동 승인 단계
- **감사 요구사항**: 완전한 실행 기록 필요

### Kafka를 선택해야 할 때:
- **고처리량 스트리밍**: 초당 수백만 이벤트 처리
- **실시간 분석**: 스트림 처리 및 집계
- **이벤트 소싱**: 이벤트 기반 아키텍처 구축
- **분리된 시스템**: 많은 서비스 간의 느슨한 결합
- **재생 기능**: 과거 이벤트 재생 필요
- **다중 컨슈머**: 많은 서비스가 같은 데이터 필요

### 하이브리드 접근법
```java
@WorkflowMethod  
public void processDocumentBatch() {
    // 오케스트레이션에 Temporal 사용
    var documents = activities.ingestDocuments();
    
    // 다운스트림 컨슈머를 위해 Kafka에 발행
    activities.publishToEventStream(documents);
    
    // Temporal 워크플로우 계속
    var processed = activities.processDocuments(documents);
}
```

## 복잡한 Kafka 플로우의 대안

### 1. Kafka Streams/ksqlDB
여러 마이크로서비스와 토픽 대신 클러스터 내 처리를 위해 Kafka Streams 사용:
```java
StreamsBuilder builder = new StreamsBuilder();
KStream<String, Document> documents = builder.stream("documents");

documents
    .filter((key, doc) -> doc.getType().equals("pdf"))
    .mapValues(this::extractText)
    .mapValues(this::generateEmbeddings)
    .to("processed-documents");
```

### 2. 더 적고, 더 넓은 토픽
메시지 키와 헤더를 사용하여 관련 이벤트 그룹화:
```java
// 대신: user-login-events, user-logout-events, user-profile-events
// 사용: 이벤트 타입이 있는 user-events
```

### 3. Temporal + Kafka 하이브리드
오케스트레이션은 Temporal, 이벤트 배포는 Kafka 사용:
```java
@WorkflowMethod
public void documentPipeline() {
    // Temporal이 파이프라인 오케스트레이션
    var result = activities.processDocument();
    
    // Kafka가 관심 있는 당사자에게 이벤트 배포
    activities.publishDocumentProcessed(result);
}
```

## 마이그레이션 전략: 복잡한 Kafka에서 Temporal로

### 1단계: 평가
1. **현재 플로우 매핑**: 모든 토픽과 변환 문서화
2. **병목 식별**: 성능 및 유지보수 문제점 찾기
3. **논리적 단계 그룹화**: 워크플로우 경계 식별

### 2단계: 하이브리드 구현
1. **새 워크플로우부터 시작**: Temporal에서 새 파이프라인 구현
2. **기존 연결**: Kafka와 Temporal을 연결하는 어댑터 사용
3. **점진적 마이그레이션**: 한 번에 하나의 워크플로우 이동

### 3단계: 통합
1. **중간 토픽 제거**: Temporal 액티비티로 대체
2. **모니터링 단순화**: 대시보드와 경보 통합
3. **인프라 축소**: 사용하지 않는 Kafka 리소스 해제

## 결론

Kafka는 고처리량 스트리밍과 이벤트 배포에 뛰어나지만, 복잡한 문서 처리 파이프라인은 종종 Temporal의 워크플로우 중심 접근법에서 이점을 얻습니다. 핵심 통찰은 Kafka의 유연성이 이점이 아닌 부담이 되는 시점을 인식하는 것입니다.

**핵심 요점:**
- **복잡성은 본질적으로 나쁘지 않음** - 하지만 목적을 가져야 함
- **Kafka는 스트리밍에서 빛남** - 설계된 대로 사용
- **Temporal은 오케스트레이션에서 우수** - 복잡한 워크플로우가 강점
- **하이브리드 접근법이 효과적** - 두 세계의 장점 결합
- **단순하게 시작** - 솔루션을 과도하게 설계하지 마세요

목표는 기술적 순수성이 아닌 아키텍처의 명확성입니다. 올바른 작업에 올바른 도구를 선택하고, 각각이 목적을 잘 수행할 때 여러 도구를 사용하는 것을 두려워하지 마세요.